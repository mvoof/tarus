//! Type definition generator
//!
//! Generates TypeScript declaration file with typed invoke overloads

use crate::indexer::ProjectIndex;
use crate::syntax::{
    extract_result_ok_type, get_base_rust_type, is_primitive_rust_type, map_rust_type_to_ts,
    should_rename_to_camel, snake_to_camel, Behavior, EntityType,
};
use std::collections::{HashSet, VecDeque};
use std::fmt::Write as _;
use std::path::Path;

/// Generate TypeScript declaration content for all commands and events
#[must_use]
pub fn generate_invoke_types(project_index: &ProjectIndex) -> String {
    let mut output = String::new();

    // Collect all commands and events
    let mut commands: Vec<CommandInfo> = Vec::new();
    let mut events: HashSet<String> = HashSet::new();

    for entry in project_index.iter_all() {
        let key = entry.key();
        let locations = entry.value();

        match key.entity {
            EntityType::Command => {
                if let Some(def) = locations
                    .iter()
                    .find(|l| l.behavior == Behavior::Definition)
                {
                    let params = def.parameters.as_ref();
                    let return_type = def.return_type.as_deref();

                    commands.push(CommandInfo {
                        name: key.name.clone(),
                        parameters: params.cloned().unwrap_or_default(),
                        return_type: return_type.map(String::from),
                    });
                }
            }
            EntityType::Event => {
                events.insert(key.name.clone());
            }
            _ => {}
        }
    }

    // Sort for stable output
    commands.sort_by(|a, b| a.name.cmp(&b.name));

    let mut sorted_events: Vec<_> = events.into_iter().collect();
    sorted_events.sort();

    // Collect initial custom types from commands
    let mut custom_types_to_process: VecDeque<String> = VecDeque::new();
    let mut discovered_types: HashSet<String> = HashSet::new();

    for cmd in &commands {
        // Check return type
        if let Some(rt) = &cmd.return_type {
            let base = get_base_rust_type(rt);
            if !is_primitive_rust_type(&base) && !base.is_empty() {
                if discovered_types.insert(base.clone()) {
                    custom_types_to_process.push_back(base);
                }
            }
        }

        // Check parameters
        for param in &cmd.parameters {
            if is_tauri_internal_type(&param.type_name) {
                continue;
            }

            let base = get_base_rust_type(&param.type_name);

            if !is_primitive_rust_type(&base) && !base.is_empty() {
                if discovered_types.insert(base.clone()) {
                    custom_types_to_process.push_back(base);
                }
            }
        }
    }

    // Header
    output.push_str("// Auto-generated by TARUS extension\n");
    output.push_str("// Do not edit manually - regenerated on Rust file changes\n\n");

    if commands.is_empty() && sorted_events.is_empty() {
        output.push_str("// No Tauri commands or events found\n");

        return output;
    }

    // Generate interfaces for custom types (recursive discovery)
    let mut generated_types: HashSet<String> = HashSet::new();

    while let Some(t_name) = custom_types_to_process.pop_front() {
        if !generated_types.insert(t_name.clone()) {
            continue;
        }

        // Try Struct first
        let struct_locs = project_index.get_locations(EntityType::Struct, &t_name);

        if let Some(def) = struct_locs
            .iter()
            .find(|l| l.behavior == Behavior::Definition)
        {
            if let Some(fields) = &def.fields {
                let rename_to_camel = should_rename_to_camel(def.attributes.as_ref());

                let _ = writeln!(output, "export interface {t_name} {{");

                for field in fields {
                    let ts_name = if rename_to_camel {
                        snake_to_camel(&field.name)
                    } else {
                        field.name.clone()
                    };

                    let ts_type = map_rust_type_to_ts(&field.type_name);
                    let _ = writeln!(output, "  {ts_name}: {ts_type};");

                    // Discover nested types
                    let base = get_base_rust_type(&field.type_name);

                    if !is_primitive_rust_type(&base) && !base.is_empty() {
                        if discovered_types.insert(base.clone()) {
                            custom_types_to_process.push_back(base);
                        }
                    }
                }

                output.push_str("}\n\n");

                continue;
            }
        }

        // Try Enum
        let enum_locs = project_index.get_locations(EntityType::Enum, &t_name);

        if let Some(def) = enum_locs
            .iter()
            .find(|l| l.behavior == Behavior::Definition)
        {
            if let Some(variants) = &def.fields {
                let _ = write!(output, "export type {t_name} = ");

                for (i, variant) in variants.iter().enumerate() {
                    if i > 0 {
                        output.push_str(" | ");
                    }

                    let _ = write!(output, "'{}'", variant.name);
                }

                output.push_str(";\n\n");

                continue;
            }
        }

        // Placeholder for unknown custom types
        let _ = writeln!(output, "export interface {t_name} {{");

        output.push_str("  // TODO: Define fields for this custom type\n");
        output.push_str("}\n\n");
    }

    // Generate interfaces for command arguments
    output.push_str("// Command argument types\n");

    for cmd in &commands {
        let has_user_params = cmd
            .parameters
            .iter()
            .any(|p| !is_tauri_internal_type(&p.type_name));

        if has_user_params {
            let interface_name = format!("{}Args", to_pascal_case(&cmd.name));
            let _ = writeln!(output, "export interface {interface_name} {{");

            for param in &cmd.parameters {
                if is_tauri_internal_type(&param.type_name) {
                    continue;
                }

                let ts_name = snake_to_camel(&param.name);
                let ts_type = map_rust_type_to_ts(&param.type_name);
                let optional = param.type_name.contains("Option<");
                let opt_marker = if optional { "?" } else { "" };
                let _ = writeln!(output, "  {ts_name}{opt_marker}: {ts_type};");
            }

            output.push_str("}\n\n");
        }
    }

    // Generate module augmentation for commands
    output.push_str("// Typed invoke overloads\n");
    output.push_str("declare module '@tauri-apps/api/core' {\n");

    for cmd in &commands {
        let return_ts = cmd.return_type.as_ref().map_or_else(
            || "void".to_string(),
            |rt| {
                let inner = extract_result_ok_type(rt);
                map_rust_type_to_ts(inner)
            },
        );

        let has_params = cmd
            .parameters
            .iter()
            .any(|p| !is_tauri_internal_type(&p.type_name));

        if has_params {
            let interface_name = format!("{}Args", to_pascal_case(&cmd.name));
            let _ = writeln!(
                output,
                "  function invoke(cmd: '{}', args: {interface_name}): Promise<{return_ts}>;",
                cmd.name
            );
        } else {
            let _ = writeln!(
                output,
                "  function invoke(cmd: '{}'): Promise<{return_ts}>;",
                cmd.name
            );
        }
    }

    output.push_str("}\n\n");

    // Generate module augmentation for events
    if !sorted_events.is_empty() {
        output.push_str("// Typed event overloads\n");
        output.push_str("declare module '@tauri-apps/api/event' {\n");

        for event in sorted_events {
            let _ = writeln!(
                output,
                "  function emit(event: '{}', payload?: any): Promise<void>;",
                event
            );
            let _ = writeln!(
                output,
                "  function listen<T = any>(event: '{}', handler: (event: {{ payload: T }}) => void): Promise<() => void>;",
                event
            );
        }

        output.push_str("}\n");
    }

    output
}

/// Write the generated types to a file
///
/// # Errors
/// Returns an error if writing the file fails
pub fn write_types_file(
    project_index: &ProjectIndex,
    workspace_root: &Path,
) -> std::io::Result<()> {
    let content = generate_invoke_types(project_index);

    // Try to find src directory for frontend
    let possible_paths = [
        workspace_root.join("src/tauri-commands.d.ts"),
        workspace_root.join("tauri-commands.d.ts"),
    ];

    // Use first path that has parent directory existing
    let target_path = possible_paths
        .iter()
        .find(|p| p.parent().is_some_and(std::path::Path::exists))
        .cloned()
        .unwrap_or_else(|| workspace_root.join("tauri-commands.d.ts"));

    std::fs::write(&target_path, content)?;

    Ok(())
}

struct CommandInfo {
    name: String,
    parameters: Vec<crate::indexer::Parameter>,
    return_type: Option<String>,
}

/// Check if type is Tauri internal (State, `AppHandle`, Window, etc.)
fn is_tauri_internal_type(type_name: &str) -> bool {
    ["State", "AppHandle", "Window", "Webview", "WebviewWindow"]
        .iter()
        .any(|&s| type_name.contains(s))
}

/// Convert `snake_case` to `PascalCase`
fn to_pascal_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize = true;

    for c in s.chars() {
        if c == '_' {
            capitalize = true;
        } else if capitalize {
            result.push(c.to_ascii_uppercase());
            capitalize = false;
        } else {
            result.push(c);
        }
    }

    result
}
